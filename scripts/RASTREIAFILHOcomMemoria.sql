/*
    GERA A ÁRVORE DE RELACIONAMENTOS DA TABELA PAI (TABINI)
    E SUAS DESCENDENTES (FILHA, NETA, ETC) ATÉ ENCONTRAR A TABFIM.

    OBS1: LIGUE O DBMS_OUTPUT ANTES DE EXECUTAR O SCRIPT

    CRIADA POR RAFAEL CAETANO PINTO   2007/10/16
    
   	Alteração 2007/10/31: Adicionado controle para busca iterativa por níveis

   	Alteração 2007/10/31: Adicionada memória das tabelas percorridas

*/
DECLARE
	PROCEDURE BUSCA_EM_NIVEL(	P_TABELA_INICIAL 		VARCHAR2
								,P_TABELA_DESTINO		VARCHAR2
								,P_PROFUNDIDADE_MINIMA	INTEGER		DEFAULT 0
								,P_PROFUNDIDADE_MAXIMA	INTEGER 	DEFAULT 5
								
	)IS
		IS_FOUND 		BOOLEAN := FALSE;
		V_DEPTH			INTEGER := P_PROFUNDIDADE_MINIMA;
		
		TYPE MEMORY	IS TABLE OF VARCHAR2(32) INDEX BY BINARY_INTEGER;
					
		ITERATION_MEMORY 		MEMORY;
		ITERATION_MEMORY_INDEX	INTEGER := 0;
		
		FUNCTION EXISTS_IN_MEMORY(ELEMENT VARCHAR2) RETURN BOOLEAN
		IS
		BEGIN
			FOR I IN 0..ITERATION_MEMORY.COUNT()-1
			LOOP
				IF ITERATION_MEMORY(I) = ELEMENT THEN
					RETURN TRUE;
				END IF;
			END LOOP;
			RETURN FALSE;
		END;
		
	    PROCEDURE FIND_CHILD(	P_INITIAL_TABLE 	VARCHAR2
						        ,P_FINAL_TABLE 		VARCHAR2
	       						,P_BOUNDARY_DEPTH 	INTEGER
	    )IS
	        CURSOR CCHILDREN(C_PARENT_TABLE VARCHAR2)
	        IS
	            SELECT DISTINCT
	                    UC.TABLE_NAME 	CHILD_TABLE
	                    ,UCR.TABLE_NAME PARENT_TABLE
	            FROM USER_CONSTRAINTS UC
	            INNER JOIN USER_CONSTRAINTS UCR ON UCR.CONSTRAINT_NAME = UC.R_CONSTRAINT_NAME
	            WHERE UCR.TABLE_NAME = UPPER(C_PARENT_TABLE)
	            AND UCR.CONSTRAINT_TYPE IN('P','U')
	            ORDER BY CHILD_TABLE;
	
	        MCHILDREN 	CCHILDREN%ROWTYPE;
	        TABULATOR 		VARCHAR2(128);
	        CURRENT_TABLE 	VARCHAR2(40);
	    BEGIN
	            OPEN CCHILDREN(P_INITIAL_TABLE);
	
	            SELECT LPAD('+- ', 3*(P_BOUNDARY_DEPTH)+3,'|  ') 
				INTO TABULATOR FROM DUAL;
				
	            IF P_BOUNDARY_DEPTH = 0 THEN --COLOCA A TABELA INICIAL NA MEMÓRIA E IMPRIME O NOME DA TABELA INICIAL
					ITERATION_MEMORY(ITERATION_MEMORY_INDEX) := UPPER(P_INITIAL_TABLE);
					ITERATION_MEMORY_INDEX := ITERATION_MEMORY_INDEX+1;
	                DBMS_OUTPUT.PUT_LINE(UPPER(P_INITIAL_TABLE));
	            END IF;

	
	    		LOOP
	            	FETCH CCHILDREN INTO MCHILDREN;
	            	EXIT WHEN CCHILDREN%NOTFOUND;
	
					SELECT DECODE(MCHILDREN.CHILD_TABLE,
									P_FINAL_TABLE,RPAD(MCHILDREN.CHILD_TABLE,40,'<'),
									MCHILDREN.CHILD_TABLE) 
					INTO CURRENT_TABLE FROM DUAL;
					
	            	
					DBMS_OUTPUT.PUT_LINE(TABULATOR||CURRENT_TABLE);

	
	                IF NOT EXISTS_IN_MEMORY(MCHILDREN.CHILD_TABLE)  -- EVITA LOOPS DE AUTO-RELACIONAMENTO
	                   AND P_BOUNDARY_DEPTH < V_DEPTH --LIMITA OS NÍVEIS DA ÁRVORE, PRINCIPALMENTE P/ EVITAR LOOPS COM RELACIONAMENTOS CICLICOS
	                   AND (MCHILDREN.CHILD_TABLE <> UPPER(P_FINAL_TABLE) OR P_FINAL_TABLE IS NULL)--EXECUTA ATÉ ENCONTRAR A TABELA DESTINO
	                THEN
						ITERATION_MEMORY(ITERATION_MEMORY_INDEX) := MCHILDREN.CHILD_TABLE;
						ITERATION_MEMORY_INDEX := ITERATION_MEMORY_INDEX+1;

	            	    FIND_CHILD(MCHILDREN.CHILD_TABLE,P_FINAL_TABLE,P_BOUNDARY_DEPTH+1);
	            	END IF;
	            	
	            	IF MCHILDREN.CHILD_TABLE = UPPER(P_FINAL_TABLE) AND P_FINAL_TABLE IS NOT NULL THEN
	            		IS_FOUND := TRUE;
	            	END IF;
	            END LOOP;
	
	            CLOSE CCHILDREN;
	    END FIND_CHILD;
	BEGIN
		
		WHILE IS_FOUND = FALSE AND V_DEPTH <= P_PROFUNDIDADE_MAXIMA
		LOOP
			ITERATION_MEMORY.DELETE;
			ITERATION_MEMORY_INDEX :=0;
			DBMS_OUTPUT.PUT_LINE(CHR(10)||CHR(10)||'--- ITERAÇÃO EM NÍVEL '||TO_CHAR(V_DEPTH+1)||' -------------------------');
			FIND_CHILD(P_TABELA_INICIAL,P_TABELA_DESTINO,0);
			V_DEPTH := V_DEPTH+1;
		END LOOP;

	END BUSCA_EM_NIVEL;
BEGIN
  dbms_output.enable(200000);
  IF '&TABELA_RAIZ' != null THEN
     BUSCA_EM_NIVEL('&TABELA_RAIZ','&TABELA_FOLHA',8,8);
  ELSE
     FOR I IN (SELECT TABLE_NAME FROM USER_TABLES
         where table_name not in (select table_name from user_constraints where constraint_type = 'R')
     ) LOOP
     BUSCA_EM_NIVEL(i.table_name,null,8,8);
     END LOOP;
  END IF;

/*   EXEMPLO DE USO:
     --GERA A ÁRVORE DE REFERENCIAS DA TABELA PAI ATÉ ENCONTRAR A TABELA FILHA
     BUSCA_EM_NIVEL('TABELAPAI','TABELAFILHA',8);

     --GERA TODA A ÁRVORE DE REFERENCIAS DA TABELAPAI
     BUSCA_EM_NIVEL('TABELAPAI',NULL,8);
*/
END;
/

