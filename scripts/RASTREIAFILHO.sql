/*
    GERA A ÁRVORE DE RELACIONAMENTOS DA TABELA PAI (TABINI)
    E SUAS DESCENDENTES (FILHA, NETA, ETC) ATÉ ENCONTRAR A TABFIM.

    OBS1: LIGUE O DBMS_OUTPUT ANTES DE EXECUTAR O SCRIPT

    CRIADA POR RAFAEL CAETANO PINTO   2007/10/16
    
   	Alteração 2007/10/31: Adicionado controle para busca iterativa por níveis

*/
DECLARE
	PROCEDURE BUSCA_EM_NIVEL(	P_TABELA_INICIAL 		VARCHAR2
								,P_TABELA_DESTINO		VARCHAR2
								,P_PROFUNDIDADE_MAXIMA	INTEGER 	DEFAULT 5
								
	)IS
		IS_FOUND 	BOOLEAN := FALSE;
		V_DEPTH		INTEGER := 0;
	    PROCEDURE FIND_CHILD(	P_INITIAL_TABLE 	VARCHAR2
						        ,P_FINAL_TABLE 		VARCHAR2
	       						,P_BOUNDARY_DEPTH 	INTEGER
	    )IS
	        CURSOR CCHILDREN(C_PARENT_TABLE VARCHAR2)
	        IS
	            SELECT DISTINCT
	                    UC.TABLE_NAME 	CHILD_TABLE
	                    ,UCR.TABLE_NAME PARENT_TABLE
	            FROM USER_CONSTRAINTS UC
	            INNER JOIN USER_CONSTRAINTS UCR ON UCR.CONSTRAINT_NAME = UC.R_CONSTRAINT_NAME
	            WHERE UCR.TABLE_NAME = UPPER(C_PARENT_TABLE)
	            AND UCR.CONSTRAINT_TYPE IN('P','U')
	            ORDER BY CHILD_TABLE;
	
	        MCHILDREN 	CCHILDREN%ROWTYPE;
	        TABULATOR 		VARCHAR2(128);
	        CURRENT_TABLE 	VARCHAR2(40);
	    BEGIN
	            OPEN CCHILDREN(P_INITIAL_TABLE);
	
	            SELECT LPAD('+- ', 3*(P_BOUNDARY_DEPTH)+3,'|  ') 
				INTO TABULATOR FROM DUAL;
	
	            IF P_BOUNDARY_DEPTH = 0 THEN --IMPRIME O NOME DA TABELA INICIAL
	                DBMS_OUTPUT.PUT_LINE(UPPER(P_INITIAL_TABLE));
	            END IF;
	
	    		LOOP
	            	FETCH CCHILDREN INTO MCHILDREN;
	            	EXIT WHEN CCHILDREN%NOTFOUND;
	
					SELECT DECODE(MCHILDREN.CHILD_TABLE,
									P_FINAL_TABLE,RPAD(MCHILDREN.CHILD_TABLE,40,'<'),
									MCHILDREN.CHILD_TABLE) 
					INTO CURRENT_TABLE FROM DUAL;
					
	            	DBMS_OUTPUT.PUT_LINE(TABULATOR||CURRENT_TABLE);
	
	                IF MCHILDREN.PARENT_TABLE <> MCHILDREN.CHILD_TABLE -- EVITA LOOPS DE AUTO-RELACIONAMENTO
	                   AND P_BOUNDARY_DEPTH < V_DEPTH --LIMITA OS NÍVEIS DA ÁRVORE EM 10, PRINCIPALMENTE P/ EVITAR LOOPS COM RELACIONAMENTOS CICLICOS
	                   AND (MCHILDREN.CHILD_TABLE <> UPPER(P_FINAL_TABLE) OR P_FINAL_TABLE IS NULL)--EXECUTA ATÉ ENCONTRAR A TABFIM
	                THEN
	            	   FIND_CHILD(MCHILDREN.CHILD_TABLE,P_FINAL_TABLE,P_BOUNDARY_DEPTH+1);
	            	END IF;
	            	
	            	IF MCHILDREN.CHILD_TABLE = UPPER(P_FINAL_TABLE) AND P_FINAL_TABLE IS NOT NULL THEN
	            		IS_FOUND := TRUE;
	            	END IF;
	            END LOOP;
	
	            CLOSE CCHILDREN;
	    END FIND_CHILD;
	BEGIN
		
		WHILE IS_FOUND = FALSE AND V_DEPTH <= P_PROFUNDIDADE_MAXIMA
		LOOP
			DBMS_OUTPUT.PUT_LINE(CHR(10)||CHR(10)||'--- ITERAÇÃO EM NÍVEL '||TO_CHAR(V_DEPTH+1)||' -------------------------');
			FIND_CHILD(P_TABELA_INICIAL,P_TABELA_DESTINO,0);
			V_DEPTH := V_DEPTH+1;
		END LOOP;
		
	END BUSCA_EM_NIVEL;
BEGIN

     BUSCA_EM_NIVEL('COR_PESSOA','EMI_SNF_DOF',8);

/*   EXEMPLO DE USO:
     --GERA A ÁRVORE DE REFERENCIAS DA TABELA PAI ATÉ ENCONTRAR A TABELA FILHA
     BUSCA_EM_NIVEL('TABELAPAI','TABELAFILHA',8);

     --GERA TODA A ÁRVORE DE REFERENCIAS DA TABELAPAI
     BUSCA_EM_NIVEL('TABELAPAI',NULL,8);
*/
END;
/


